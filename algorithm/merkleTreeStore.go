package algorithm

import (
	"crypto/sha256"
	"hash"
	"math"
)

func HashMerkleBranchesForFile(left []byte, right []byte, hash hash.Hash) *Hash {
	hash.Reset()
	hash.Write(left)
	hash.Write(right)
	sum := hash.Sum(nil)
	hash.Reset()
	var res [32]byte
	copy(res[:], sum)
	newHash := Hash(res)
	return &newHash
}

// BuildMerkleTreeStore creates a merkle tree from a slice of transactions,
// stores it using a linear array, and returns a slice of the backing array.  A
// linear array was chosen as opposed to an actual tree structure since it uses
// about half as much memory.  The following describes a merkle tree and how it
// is stored in a linear array.
//
// A merkle tree is a tree in which every non-leaf node is the hash of its
// children nodes.  A diagram depicting how this works for bitcoin transactions
// where h(x) is a double sha256 follows:
//
//	         root = h1234 = h(h12 + h34)
//	        /                           \
//	  h12 = h(h1 + h2)            h34 = h(h3 + h4)
//	   /            \              /            \
//	h1 = h(tx1)  h2 = h(tx2)    h3 = h(tx3)  h4 = h(tx4)
//
// The above stored as a linear array is as follows:
//
// 	[h1 h2 h3 h4 h12 h34 root]
//
// As the above shows, the merkle root is always the last element in the array.
//
// The number of inputs is not always a power of two which results in a
// balanced tree structure as above.  In that case, parent nodes with no
// children are also zero and parent nodes with only a single left node
// are calculated by concatenating the left node with itself before hashing.
// Since this function uses nodes that are pointers to the hashes, empty nodes
// will be nil.
//
// The additional bool parameter indicates if we are generating the merkle tree
// using witness transaction id's rather than regular transaction id's. This
// also presents an additional case wherein the wtxid of the coinbase transaction
// is the zeroHash.
func BuildMerkleTreeStore(pls []*ProofLeaf, pidByte []byte) []*ProofLeaf {
	// Calculate how many entries are required to hold the binary merkle
	// tree as a linear array and create an array of that size.
	nextPoT := nextPowerOfTwo(len(pls))
	arraySize := nextPoT*2 - 1
	merkles := make([]*ProofLeaf, arraySize)

	// Create the base transaction hashes and populate the array with them.
	for i, pl := range pls {
		merkles[i] = &ProofLeaf{
			C:             pl.C,
			ChallengeHash: pl.ChallengeHash,
			Hash:          pl.GetHash(pidByte),
		}
	}

	// Start the array offset after the last transaction and adjusted to the
	// next power of two.
	offset := nextPoT
	for i := 0; i < arraySize-1; i += 2 {
		switch {
		// When there is no left child node, the parent is nil too.
		case merkles[i] == nil:
			merkles[offset] = nil

		// When there is no right child, the parent is generated by
		// hashing the concatenation of the left child with itself.
		case merkles[i+1] == nil:
			newHash := &ProofLeaf{
				Hash: HashMerkleBranches(merkles[i].Hash, merkles[i].Hash),
			}
			merkles[offset] = newHash

		// The normal case sets the parent node to the double sha256
		// of the concatentation of the left and right children.
		default:
			newHash := &ProofLeaf{
				Hash: HashMerkleBranches(merkles[i].Hash, merkles[i+1].Hash),
			}
			merkles[offset] = newHash
		}
		offset++
	}

	return merkles
}

const (
	left  = 1
	right = -1
)

type MerkleBlock struct {
	H *ProofLeaf
	I int
}

func GetMerkleBlock(merkles []*ProofLeaf, i int) []*MerkleBlock {
	proofNum := (len(merkles) + 1) >> 1
	exponent := uint(math.Log2(float64(proofNum)))
	var merkleBlock []*MerkleBlock
	if i%2 == 1 {
		merkleBlock = append(merkleBlock, &MerkleBlock{
			H: merkles[i+right],
			I: right,
		})
	} else {
		merkleBlock = append(merkleBlock, &MerkleBlock{
			H: merkles[i+left],
			I: left,
		})
	}
	i = (2*proofNum - 1<<exponent) + (i-2*proofNum+2<<exponent)/2
	for exponent > 1 {
		temp := &MerkleBlock{}
		if i%2 == 1 {
			temp.I = right
		} else {
			temp.I = left
		}
		i += temp.I
		temp.H = merkles[i]
		exponent--
		merkleBlock = append(merkleBlock, temp)
		i = (2*proofNum - 1<<exponent) + (i-2*proofNum+2<<exponent)/2
	}
	return merkleBlock
}

func VerifyMerkleBlock(merkleBlocks []*MerkleBlock, proof *Hash, root *Hash) bool {
	//l := len(merkleBlocks)
	// proof 是否为  hash(pid +hash(storeChallenge+content))
	res := proof
	for _, mb := range merkleBlocks {
		if mb.H == nil {
			res = HashMerkleBranches(res, res)
			continue
		}

		if mb.I == left {
			res = HashMerkleBranches(res, mb.H.Hash)
		} else {
			res = HashMerkleBranches(mb.H.Hash, res)
		}
	}
	return res.Equal(root[:])
}

func VerifyProofLeaf(pidByte []byte, challengeByte []byte, content []byte, proofLeaf *Hash, hashSha256 hash.Hash) bool {
	hashSha256.Reset()
	hashSha256.Write(challengeByte)
	hashSha256.Write(content)
	sum := hashSha256.Sum(nil)
	hashSha256.Reset()
	hashSha256.Write(pidByte)
	hashSha256.Write(sum)
	sum = hashSha256.Sum(nil)
	return proofLeaf.Equal(sum)
}

func VerifyProofLeaf2(pidByte []byte, challengeHash []byte, proofLeaf *Hash, hashSha256 hash.Hash) bool {
	hashSha256.Reset()
	hashSha256.Write(pidByte)
	hashSha256.Write(challengeHash)
	sum := hashSha256.Sum(nil)
	return proofLeaf.Equal(sum)
}

// nextPowerOfTwo returns the next highest power of two from a given number if
// it is not already a power of two.  This is a helper function used during the
// calculation of a merkle tree.
func nextPowerOfTwo(n int) int {
	// Return the number if it's already a power of 2.
	if n&(n-1) == 0 {
		return n
	}

	// Figure out and return the next power of two.
	exponent := uint(math.Log2(float64(n))) + 1
	return 1 << exponent // 2^exponent
}

// HashMerkleBranches takes two hashes, treated as the left and right tree
// nodes, and returns the hash of their concatenation.  This is a helper
// function used to aid in the generation of a merkle tree.
func HashMerkleBranches(left *Hash, right *Hash) *Hash {
	// Concatenate the left and right nodes.
	var hash [32 * 2]byte
	copy(hash[:32], left[:])
	copy(hash[32:], right[:])

	newHash := Hash(sha256.Sum256(hash[:]))
	return &newHash
}
